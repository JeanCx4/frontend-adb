import React, { useState, useRef, useEffect } from 'react';
import Webcam from 'react-webcam';
import { BrowserMultiFormatReader } from '@zxing/library';
import './EscanerQR.css';

const EscanerQRFuncional = ({ onQRDetected, onClose }) => {
  const [scanning, setScanning] = useState(false);
  const [error, setError] = useState('');
  const [cameraAccess, setCameraAccess] = useState(false);
  const [procesando, setProcesando] = useState(false);
  const [metodosIntentados, setMetodosIntentados] = useState([]);
  const webcamRef = useRef(null);
  const codeReader = useRef(null);
  const intervalRef = useRef(null);

  useEffect(() => {
    // Configurar el lector con configuraciones optimizadas
    codeReader.current = new BrowserMultiFormatReader();
    console.log('üîß Esc√°ner QR inicializado');
    
    return () => {
      stopScanning();
      if (codeReader.current) {
        codeReader.current.reset();
      }
    };
  }, []);

  const startScanning = () => {
    if (!webcamRef.current?.video) {
      setError('‚ùå C√°mara no disponible');
      return;
    }

    console.log('üéØ Iniciando escaneo...');
    setScanning(true);
    setError('');
    setMetodosIntentados([]);
    
    intervalRef.current = setInterval(tryDetectQR, 1000); // Cada segundo
  };

  const stopScanning = () => {
    console.log('‚èπÔ∏è Deteniendo escaneo...');
    setScanning(false);
    setProcesando(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const tryDetectQR = async () => {
    if (procesando || !webcamRef.current?.video) return;
    
    setProcesando(true);
    const video = webcamRef.current.video;
    
    if (video.readyState !== video.HAVE_ENOUGH_DATA) {
      setProcesando(false);
      return;
    }

    try {
      // M√©todo 1: ZXing con canvas
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      
      // Dibujar el frame actual
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Intentar con ZXing
      try {
        const result = await codeReader.current.decodeFromCanvas(canvas);
        if (result?.text) {
          console.log('‚úÖ ZXing detect√≥:', result.text);
          handleDetection(result.text, 'ZXing Local');
          return;
        }
      } catch (zxingError) {
        console.log('‚ö†Ô∏è ZXing fall√≥:', zxingError.message);
        if (!metodosIntentados.includes('ZXing')) {
          setMetodosIntentados(prev => [...prev, 'ZXing']);
        }
      }

      // M√©todo 2: Solo si ZXing fall√≥ varias veces, usar API
      if (metodosIntentados.includes('ZXing')) {
        await tryWithAPI(canvas);
      }

    } catch (error) {
      console.log('‚ùå Error en detecci√≥n:', error);
    } finally {
      setProcesando(false);
    }
  };

  const tryWithAPI = async (canvas) => {
    try {
      console.log('üåê Intentando con API...');
      
      // Convertir canvas a blob
      const blob = await new Promise(resolve => {
        canvas.toBlob(resolve, 'image/jpeg', 0.9);
      });

      // Crear FormData
      const formData = new FormData();
      formData.append('file', blob, 'qr.jpg');

      // Intentar con API simple y confiable
      const response = await fetch('https://api.qrserver.com/v1/read-qr-code/', {
        method: 'POST',
        body: formData,
        timeout: 5000 // 5 segundos timeout
      });

      if (response.ok) {
        const data = await response.json();
        console.log('üìä Respuesta API:', data);
        
        if (data && data[0] && data[0].symbol && data[0].symbol[0] && data[0].symbol[0].data) {
          const qrText = data[0].symbol[0].data;
          console.log('‚úÖ API detect√≥:', qrText);
          handleDetection(qrText, 'QR Server API');
          return;
        }
      }

      if (!metodosIntentados.includes('API')) {
        setMetodosIntentados(prev => [...prev, 'API']);
      }

    } catch (apiError) {
      console.log('‚ùå API fall√≥:', apiError);
      if (!metodosIntentados.includes('API')) {
        setMetodosIntentados(prev => [...prev, 'API Failed']);
      }
    }
  };

  const handleDetection = (qrText, metodo) => {
    console.log(`üéØ QR detectado con ${metodo}:`, qrText);
    stopScanning();
    
    const dni = extractDNI(qrText);
    
    if (dni) {
      console.log('‚úÖ DNI extra√≠do:', dni);
      onQRDetected(dni);
    } else {
      setError(`‚ùå QR detectado pero no contiene un DNI v√°lido: "${qrText}"`);
      console.log('‚ùå No se pudo extraer DNI de:', qrText);
      setTimeout(() => {
        setError('');
        startScanning(); // Reiniciar escaneo
      }, 3000);
    }
  };

  const extractDNI = (text) => {
    console.log('üîç Extrayendo DNI de:', text);
    const cleanText = text.trim();
    
    // 1. DNI directo (8-10 d√≠gitos)
    if (/^\d{8,10}$/.test(cleanText)) {
      console.log('‚úÖ DNI directo encontrado:', cleanText);
      return cleanText;
    }
    
    // 2. JSON con dni
    try {
      const parsed = JSON.parse(cleanText);
      if (parsed.dni || parsed.DNI) {
        console.log('‚úÖ DNI desde JSON:', parsed.dni || parsed.DNI);
        return parsed.dni || parsed.DNI;
      }
    } catch (e) {
      // No es JSON
    }
    
    // 3. URL con patr√≥n /estudiante/12345678
    const urlMatch = cleanText.match(/\/(?:perfil-)?estudiante\/(\d{8,10})/i);
    if (urlMatch) {
      console.log('‚úÖ DNI desde URL:', urlMatch[1]);
      return urlMatch[1];
    }
    
    // 4. Patr√≥n dni=12345678
    const paramMatch = cleanText.match(/(?:dni|id)[=:](\d{8,10})/i);
    if (paramMatch) {
      console.log('‚úÖ DNI desde par√°metro:', paramMatch[1]);
      return paramMatch[1];
    }
    
    // 5. Cualquier secuencia de 8-10 d√≠gitos
    const digitMatch = cleanText.match(/\b(\d{8,10})\b/);
    if (digitMatch) {
      console.log('‚úÖ DNI desde d√≠gitos:', digitMatch[1]);
      return digitMatch[1];
    }
    
    console.log('‚ùå No se encontr√≥ DNI en el texto');
    return null;
  };

  const captureManual = async () => {
    if (!webcamRef.current) {
      setError('‚ùå C√°mara no disponible');
      return;
    }

    try {
      setProcesando(true);
      console.log('üì∏ Captura manual iniciada...');
      
      // Capturar imagen
      const imageSrc = webcamRef.current.getScreenshot();
      if (!imageSrc) {
        throw new Error('No se pudo capturar la imagen');
      }

      // Convertir data URL a blob
      const response = await fetch(imageSrc);
      const blob = await response.blob();
      
      // Crear canvas desde la imagen
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        // Intentar con ZXing primero
        try {
          const result = await codeReader.current.decodeFromCanvas(canvas);
          if (result?.text) {
            handleDetection(result.text, 'Manual - ZXing');
            return;
          }
        } catch (e) {
          console.log('ZXing manual fall√≥, intentando API...');
        }
        
        // Si ZXing falla, usar API
        await tryWithAPI(canvas);
        
        if (!procesando) {
          setError('‚ùå No se detect√≥ c√≥digo QR en la captura');
          setTimeout(() => setError(''), 3000);
        }
      };
      
      img.src = imageSrc;

    } catch (error) {
      console.error('‚ùå Error en captura manual:', error);
      setError('‚ùå Error al capturar imagen: ' + error.message);
      setTimeout(() => setError(''), 3000);
    } finally {
      setProcesando(false);
    }
  };

  const handleUserMedia = () => {
    setCameraAccess(true);
    console.log('üìπ C√°mara iniciada correctamente');
  };

  const handleUserMediaError = (error) => {
    console.error('‚ùå Error de c√°mara:', error);
    setError('‚ùå No se pudo acceder a la c√°mara. Verifica los permisos.');
    setCameraAccess(false);
  };

  return (
    <div className="escaner-qr-overlay">
      <div className="escaner-qr-container">
        <div className="escaner-qr-header">
          <h3>üì± Esc√°ner QR Funcional</h3>
          <button className="btn-close-escaner" onClick={onClose}>‚úï</button>
        </div>

        <div className="escaner-qr-content">
          {error && (
            <div className="alert alert-danger">
              {error}
            </div>
          )}

          <div className="camera-container">
            <Webcam
              ref={webcamRef}
              audio={false}
              width={400}
              height={300}
              onUserMedia={handleUserMedia}
              onUserMediaError={handleUserMediaError}
              mirrored={false}
              videoConstraints={{
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: "environment"
              }}
              style={{
                transform: 'scaleX(1)'
              }}
            />
            
            {(scanning || procesando) && (
              <div className="scanning-overlay">
                <div className="scanning-frame-simple">
                  <div className="corner corner-tl"></div>
                  <div className="corner corner-tr"></div>
                  <div className="corner corner-bl"></div>
                  <div className="corner corner-br"></div>
                </div>
                <p className="scanning-text">
                  {procesando ? 'üîÑ Procesando...' : 'üîç Escaneando...'}
                </p>
                {metodosIntentados.length > 0 && (
                  <p className="scanning-methods">
                    M√©todos: {metodosIntentados.join(', ')}
                  </p>
                )}
              </div>
            )}
          </div>

          <div className="escaner-controls">
            {!scanning ? (
              <div className="d-flex gap-2 justify-content-center flex-wrap">
                <button 
                  className="btn btn-success"
                  onClick={startScanning}
                  disabled={!cameraAccess || procesando}
                >
                  üéØ Iniciar Escaneo
                </button>
                <button 
                  className="btn btn-info"
                  onClick={captureManual}
                  disabled={!cameraAccess || procesando}
                >
                  üì∏ Captura Manual
                </button>
              </div>
            ) : (
              <button 
                className="btn btn-warning btn-lg"
                onClick={stopScanning}
                disabled={procesando}
              >
                ‚èπÔ∏è Detener
              </button>
            )}
          </div>

          <div className="escaner-info">
            <div className="alert alert-info">
              <strong>üí° Instrucciones:</strong>
              <ul>
                <li>üéØ <strong>Autom√°tico:</strong> Escaneo continuo cada segundo</li>
                <li>üì∏ <strong>Manual:</strong> Captura una foto y la procesa</li>
                <li>üîç Coloca el QR centrado y con buena iluminaci√≥n</li>
                <li>üì± Aseg√∫rate de que el QR contenga un DNI de 8-10 d√≠gitos</li>
              </ul>
              <div className="mt-2">
                <small className="text-muted">
                  <strong>Estado:</strong> {scanning ? 'üîÑ Activo' : '‚è∏Ô∏è Detenido'} | 
                  <strong>Procesando:</strong> {procesando ? '‚ö° S√≠' : 'üí§ No'} |
                  <strong>C√°mara:</strong> {cameraAccess ? '‚úÖ OK' : '‚ùå No'}
                </small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EscanerQRFuncional;
